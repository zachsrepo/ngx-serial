{"hash":"8cc004f625e31553853bd2108d3664fd1d71af18","fesm2022":[{"exports":["NgxSerial"],"facadeModuleId":"C:\\repos\\ngx-serial\\dist\\ngx-serial\\esm2022\\ngx-serial.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["C:\\repos\\ngx-serial\\dist\\ngx-serial\\esm2022\\lib\\ngx-serial.mjs","C:\\repos\\ngx-serial\\dist\\ngx-serial\\esm2022\\public-api.mjs","C:\\repos\\ngx-serial\\dist\\ngx-serial\\esm2022\\ngx-serial.mjs"],"name":"ngx-serial","type":"chunk","dynamicImports":[],"fileName":"ngx-serial.mjs","implicitlyLoadedBefore":[],"importedBindings":{},"imports":[],"modules":{"C:\\repos\\ngx-serial\\dist\\ngx-serial\\esm2022\\lib\\ngx-serial.mjs":{"code":"class NgxSerial {\n    port;\n    options = { baudRate: 9600, dataBits: 8, parity: 'none', bufferSize: 256, flowControl: 'none' }; //Default\n    writer;\n    readFunction;\n    controlCharacter = \"\\n\";\n    reader;\n    readableStreamClosed;\n    writableStreamClosed;\n    keepReading = true;\n    constructor(readFunction, options, controlCharacter) {\n        this.readFunction = readFunction;\n        if (options)\n            this.options = options;\n        if (controlCharacter)\n            this.controlCharacter = controlCharacter;\n    }\n    async sendData(data) {\n        await this.writer.write(data);\n    }\n    async readLoop() {\n        while (this.port.readable && this.keepReading) {\n            const textDecoder = new TextDecoderStream();\n            //const readableStream = new ReadableStream();\n            this.readableStreamClosed = this.port.readable.pipeTo(textDecoder.writable);\n            this.reader = textDecoder.readable\n                .pipeThrough(new TransformStream(new LineBreakTransformer(this.controlCharacter)))\n                .getReader();\n            try {\n                while (true) {\n                    const { value, done } = await this.reader.read();\n                    if (done) {\n                        break;\n                    }\n                    if (value) {\n                        this.readFunction(value);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Read Loop error. Have the serial device been disconnected ? \");\n            }\n        }\n    }\n    async close(callback) {\n        this.keepReading = false;\n        this.reader.cancel();\n        await this.readableStreamClosed.catch(() => { });\n        this.writer.close();\n        await this.writableStreamClosed;\n        await this.port.close();\n        callback(null);\n    }\n    async connect(callback) {\n        this.keepReading = true;\n        if (\"serial\" in navigator) {\n            // The Web Serial API is supported by the browser.\n            let nav = navigator;\n            const ports = await nav.serial.getPorts();\n            try {\n                this.port = await nav.serial.requestPort();\n            }\n            catch (error) {\n                console.error(\"Requesting port error: \" + error);\n                return;\n            }\n            try {\n                await this.port.open(this.options);\n            }\n            catch (error) {\n                console.error(\"Opening port error: \" + error);\n                return;\n            }\n            const textEncoder = new TextEncoderStream();\n            this.writableStreamClosed = textEncoder.readable.pipeTo(this.port.writable);\n            this.writer = textEncoder.writable.getWriter();\n            this.readLoop();\n            callback(this.port);\n        }\n        else {\n            console.error(\"This browser does NOT support the Web Serial API\");\n        }\n    }\n}\nclass LineBreakTransformer {\n    container = \"\";\n    controlCharacter;\n    constructor(controlCharacter) {\n        this.container = '';\n        this.controlCharacter = controlCharacter;\n    }\n    transform(chunk, controller) {\n        this.container += chunk;\n        const lines = this.container.split(this.controlCharacter);\n        this.container = lines.pop();\n        lines.forEach((line) => controller.enqueue(line));\n    }\n    flush(controller) {\n        controller.enqueue(this.container);\n    }\n}","originalLength":13109,"removedExports":[],"renderedExports":["NgxSerial"],"renderedLength":3427},"C:\\repos\\ngx-serial\\dist\\ngx-serial\\esm2022\\public-api.mjs":{"code":"/*\n * Public API Surface of ngx-serial\n */\n/*export * from './lib/ngx-serial.service';\nexport * from './lib/ngx-serial.component';\nexport * from './lib/ngx-serial.module';*/","originalLength":846,"removedExports":[],"renderedExports":[],"renderedLength":173},"C:\\repos\\ngx-serial\\dist\\ngx-serial\\esm2022\\ngx-serial.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":496,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"class NgxSerial {\n    port;\n    options = { baudRate: 9600, dataBits: 8, parity: 'none', bufferSize: 256, flowControl: 'none' }; //Default\n    writer;\n    readFunction;\n    controlCharacter = \"\\n\";\n    reader;\n    readableStreamClosed;\n    writableStreamClosed;\n    keepReading = true;\n    constructor(readFunction, options, controlCharacter) {\n        this.readFunction = readFunction;\n        if (options)\n            this.options = options;\n        if (controlCharacter)\n            this.controlCharacter = controlCharacter;\n    }\n    async sendData(data) {\n        await this.writer.write(data);\n    }\n    async readLoop() {\n        while (this.port.readable && this.keepReading) {\n            const textDecoder = new TextDecoderStream();\n            //const readableStream = new ReadableStream();\n            this.readableStreamClosed = this.port.readable.pipeTo(textDecoder.writable);\n            this.reader = textDecoder.readable\n                .pipeThrough(new TransformStream(new LineBreakTransformer(this.controlCharacter)))\n                .getReader();\n            try {\n                while (true) {\n                    const { value, done } = await this.reader.read();\n                    if (done) {\n                        break;\n                    }\n                    if (value) {\n                        this.readFunction(value);\n                    }\n                }\n            }\n            catch (error) {\n                console.error(\"Read Loop error. Have the serial device been disconnected ? \");\n            }\n        }\n    }\n    async close(callback) {\n        this.keepReading = false;\n        this.reader.cancel();\n        await this.readableStreamClosed.catch(() => { });\n        this.writer.close();\n        await this.writableStreamClosed;\n        await this.port.close();\n        callback(null);\n    }\n    async connect(callback) {\n        this.keepReading = true;\n        if (\"serial\" in navigator) {\n            // The Web Serial API is supported by the browser.\n            let nav = navigator;\n            const ports = await nav.serial.getPorts();\n            try {\n                this.port = await nav.serial.requestPort();\n            }\n            catch (error) {\n                console.error(\"Requesting port error: \" + error);\n                return;\n            }\n            try {\n                await this.port.open(this.options);\n            }\n            catch (error) {\n                console.error(\"Opening port error: \" + error);\n                return;\n            }\n            const textEncoder = new TextEncoderStream();\n            this.writableStreamClosed = textEncoder.readable.pipeTo(this.port.writable);\n            this.writer = textEncoder.writable.getWriter();\n            this.readLoop();\n            callback(this.port);\n        }\n        else {\n            console.error(\"This browser does NOT support the Web Serial API\");\n        }\n    }\n}\nclass LineBreakTransformer {\n    container = \"\";\n    controlCharacter;\n    constructor(controlCharacter) {\n        this.container = '';\n        this.controlCharacter = controlCharacter;\n    }\n    transform(chunk, controller) {\n        this.container += chunk;\n        const lines = this.container.split(this.controlCharacter);\n        this.container = lines.pop();\n        lines.forEach((line) => controller.enqueue(line));\n    }\n    flush(controller) {\n        controller.enqueue(this.container);\n    }\n}\n\n/*\n * Public API Surface of ngx-serial\n */\n/*export * from './lib/ngx-serial.service';\nexport * from './lib/ngx-serial.component';\nexport * from './lib/ngx-serial.module';*/\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxSerial };\n//# sourceMappingURL=ngx-serial.mjs.map\n","map":null,"preliminaryFileName":"ngx-serial.mjs","sourcemapFileName":"ngx-serial.mjs.map"},{"fileName":"ngx-serial.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"ngx-serial.mjs\",\"sources\":[\"../../../projects/ngx-serial/src/lib/ngx-serial.ts\",\"../../../projects/ngx-serial/src/public-api.ts\",\"../../../projects/ngx-serial/src/ngx-serial.ts\"],\"sourcesContent\":[\"import { NONE_TYPE } from \\\"@angular/compiler\\\";\\r\\n\\r\\nexport class NgxSerial {\\r\\n\\r\\n    private port: any;\\r\\n    private options = { baudRate: 9600, dataBits: 8, parity: 'none', bufferSize: 256, flowControl: 'none' }; //Default\\r\\n    private writer: any;\\r\\n    private readFunction: Function;\\r\\n    private controlCharacter: string = \\\"\\\\n\\\";\\r\\n    private reader:any;\\r\\n    private readableStreamClosed:any;\\r\\n    private writableStreamClosed:any;\\r\\n    private keepReading:boolean = true;\\r\\n  \\r\\n    constructor(readFunction: Function, options?: any, controlCharacter?: any) {\\r\\n      this.readFunction = readFunction;\\r\\n      if (options)\\r\\n        this.options = options;\\r\\n      if (controlCharacter)\\r\\n        this.controlCharacter = controlCharacter;\\r\\n  \\r\\n    }\\r\\n    public async sendData(data: string) {\\r\\n      await this.writer.write(data);\\r\\n    }\\r\\n  \\r\\n    private async readLoop() {\\r\\n      \\r\\n  \\r\\n      while (this.port.readable && this.keepReading ) {\\r\\n        const textDecoder = new TextDecoderStream();\\r\\n        //const readableStream = new ReadableStream();\\r\\n        this.readableStreamClosed = this.port.readable.pipeTo(textDecoder.writable);\\r\\n        this.reader = textDecoder.readable\\r\\n          .pipeThrough(new TransformStream(new LineBreakTransformer(this.controlCharacter)))\\r\\n          .getReader();\\r\\n  \\r\\n        try {\\r\\n          while (true) {\\r\\n            const { value, done } = await this.reader.read();\\r\\n            if (done) {\\r\\n              break;\\r\\n            }\\r\\n            if (value) {\\r\\n              this.readFunction(value);\\r\\n            }\\r\\n          }\\r\\n        } catch (error) {\\r\\n          console.error(\\\"Read Loop error. Have the serial device been disconnected ? \\\");\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    public async close(callback:Function) {\\r\\n      this.keepReading = false;\\r\\n      this.reader.cancel();\\r\\n      await this.readableStreamClosed.catch(() => {});\\r\\n      this.writer.close();\\r\\n      await this.writableStreamClosed;\\r\\n      await this.port.close();\\r\\n      callback(null);\\r\\n    }\\r\\n  \\r\\n    public async connect(callback:Function) {\\r\\n      this.keepReading = true;\\r\\n      if (\\\"serial\\\" in navigator) {\\r\\n        // The Web Serial API is supported by the browser.\\r\\n        let nav: any = navigator;\\r\\n        const ports = await nav.serial.getPorts();\\r\\n  \\r\\n        try {\\r\\n          this.port = await nav.serial.requestPort();\\r\\n  \\r\\n        } catch (error) {\\r\\n          console.error(\\\"Requesting port error: \\\" + error);\\r\\n          return;\\r\\n        }\\r\\n  \\r\\n        try {\\r\\n         await this.port.open(this.options);\\r\\n  \\r\\n  \\r\\n        } catch (error) {\\r\\n          console.error(\\\"Opening port error: \\\" + error);\\r\\n          return;\\r\\n        }\\r\\n  \\r\\n        const textEncoder = new TextEncoderStream();\\r\\n        this.writableStreamClosed = textEncoder.readable.pipeTo(this.port.writable);\\r\\n        this.writer = textEncoder.writable.getWriter();\\r\\n  \\r\\n        this.readLoop();\\r\\n  \\r\\n        callback(this.port);\\r\\n  \\r\\n      } else {\\r\\n        console.error(\\\"This browser does NOT support the Web Serial API\\\");\\r\\n      }\\r\\n  \\r\\n    }\\r\\n  }\\r\\n  \\r\\n  class LineBreakTransformer {\\r\\n    container: any=\\\"\\\";\\r\\n    private controlCharacter: string;\\r\\n  \\r\\n    constructor(controlCharacter: string) {\\r\\n      this.container = '';\\r\\n      this.controlCharacter = controlCharacter\\r\\n    }\\r\\n  \\r\\n    transform(chunk:any, controller:any) {\\r\\n      this.container += chunk;\\r\\n      const lines = this.container.split(this.controlCharacter);\\r\\n      this.container = lines.pop();\\r\\n      lines.forEach((line: any) => controller.enqueue(line));\\r\\n    }\\r\\n  \\r\\n    flush(controller:any) {\\r\\n      controller.enqueue(this.container);\\r\\n    }\\r\\n  }\",\"/*\\r\\n * Public API Surface of ngx-serial\\r\\n */\\r\\n\\r\\n/*export * from './lib/ngx-serial.service';\\r\\nexport * from './lib/ngx-serial.component';\\r\\nexport * from './lib/ngx-serial.module';*/\\r\\nexport * from './lib/ngx-serial';\\r\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}